##### 静态条件：

静态条件是指在多个线程访问同一个共有资源的时候,由于出现不恰当的执行顺序引起的结果错误

##### 延迟初始化的静态条件：

延迟初始化是通过先检查后执行，从而减少对数据的不必要的开销，但是在多线程环境下，可能有多个线程同时进入判断从而创建多个TypePojo对象从而产生静态条件

```java
public class LazyInitRace{
    private TypePojo pojo = null;
    
    public TypePojo getPojo(){
        if(null == pojo){
            pojo = new TypePojo();
        }
        return pojo;
    }
}
```

静态条件并不会一直产生错误，而是不正当执行的静态条件才会引发错误。

##### 静态条件解决

静态条件因为在多线程中出现不正当执行的时候回出现错误，可以通过加锁或者是原子操作来限制多个线程同时修改一个状态。



##### 内置锁

java的内置锁属于互斥锁，在多线程环境下，一个对象获取了同步代码块的锁对象，如果在该对象没有释放锁资源以前所有的对象都需要都需要等待或者阻塞。



##### 重入

- 在java中当一个对象访问其他线程持有锁的请求时，就会出现等待，但是如果一个对象访问已经获取锁对象的请求时，那么这个请求就会访问成功，这说明java中锁操作的粒度是按照线程，而不是根据方法调用。
- 在jvm中每个锁对象都关联一个计数器和一个所有者，当计数器等于0 时，说明该锁没有被任何线程锁持有，当线程持有该锁后对象的计数器变为1且记录下锁的持有线程，如果线程在此获取该锁那么计数器递增，如果线程释放那么计数器递减



##### 同步代码

在java中实现同步代码是为了在是共享的数据从并行访问转化成串行访问这样就可以在多线程中使数据保持安全



##### 使用锁来保护状态

当多个数据使用访问一个共享的状态的时候，不能只在写的时候加锁，可能会出现读到的数据不一致的情况，应该在读上也增加同步锁，根据锁重入的特性可保护数据的状态



































