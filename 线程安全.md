# java并发编程实战

## 线程安全

1. 什么是线程安全性

   线程安全就是一个类在多个线程访问的情况下，这个类依然能够保证正确的执行

   - 多个线程访问一个类，如果不考虑线程在运行状态下的调度和交替执行，且不用额外的同步或者在调用的地方做其他的协调操作，那么这个类是线程安全的
   - 在一个线程安全的类的实例中进行顺序或者并发的一系列操作，都不会导致实例处于无效状态

   对象线程无状态：无状态对象是指不包含域也没有引用其他的域的引用。一次特定的计算的瞬时状态[^1]，会唯一的存在本地变量中，这些本地变量存在线程的栈中[^2]，只有当前执行的线程才可以访问，也就相当于每次访问都没有公共的数据只有自己线程生成的数据，所以无状态对象是安全的

   [^1]: 就是没有内存变量，也没有其他对象的应用，单纯的一次操作
   [^2]: 每个线程在执行的时候都会有个一个自己的栈，在栈内保存线程的信息，如果线程中的信息没有同步方法或者volition关键字，那么线程中的字段就不会读取主存的信息，而是直接读取自己的栈的数据

2. 原子性

   - 原子性：是指在多线程中执行一段代码，在执行过程中没有其他的线程的命令插入到其中执行，也就是说一个线程在执行的时候不能有任何其他线程打扰
   - 原子操作：不能作为一个单独的、不可分割的操作去执行

   1. 静态条件

      静态条件是指在多个线程访问同一个共有资源的时候,由于出现不恰当的执行顺序引起的结果错误,代码如下，因为```count++``` 在jvm内存中有三个操作，读-改-写，所以对于incrCount方法来并非线程安全且存在静态条件，从而是count的结果不可靠

   ``` java
   public class UnsafeCountingFactorizer {
       private long count = 0;
       //私有内部类，外部创建
       private UnsafeCountingFactorizer(){ }
   
       public long getCount(){ return count; }
   
       public void incrCount(){
           count++;
       }
       /*
        * 使用静态内部类实现单例，这样就会操作同一个count产生静态条件
        */
       private static class SimpleClassFactory{
           private static final UnsafeCountingFactorizer INSTANCE = new UnsafeCountingFactorizer();
       }
       public static UnsafeCountingFactorizer getInstance(){
           return SimpleClassFactory.INSTANCE;
       }
   }
   ```

   - 数据竞争：出现于没有使用同步来协调那些非final域访问的情况，一个线程可以读取另一个线程刚刚写入的变量，如果两个线程都没有使用同步，那么就会出现数据竞争（详情后续）

   2. 延迟初始化的静态条件：

      1. 延迟初始化是通过先检查后执行，从而减少对数据的不必要的开销，但是在多线程环境下，可能有多个线程同时进入判断从而创建多个TypePojo对象从而产生静态条件，这种静态条件就像是单例中的懒汉模式

      ```java
      public class LazyInitRace{
          private TypePojo pojo = null;
          
          public TypePojo getPojo(){
              if(null == pojo){
                  pojo = new TypePojo();
              }
              return pojo;
          }
      }
      ```

      ​	静态条件并不会一直产生错误，而是不正当执行的静态条件才会引发错误

   3. 复合操作

      复合操作就是只一组操作，类似于读-改-写，或者先检查后执行，但是这样的操作还是会引起静态条件，因此使用同步机制或者线程安全对象来管理状态可以使复合操作原子化。

3. 加锁机制

   在各个变量之间并不是彼此独立的，而是更改其中的某个值对其他的变量会产生约束，即使这些变量使用的是线程安全对象，也需要在更新是同步更新其他的值。这样就需要在单个原子操作中执行。

   1. 内置锁

      java的内置锁属于互斥锁，在多线程环境下，一个对象获取了同步代码块的锁对象，如果在该对象没有释放锁资源以前所有的对象都需要都需要等待或者阻塞。

      - 同步代码块:包括一个作为锁的对象引用，和一个由锁保护的代码块
      - synchronize关键字：横跨整个方法体的同步代码块，而当前方法的锁对象就是调用方法的对象，当方法为静态方法是，方法的锁为Class对象

      ``` synchronized(lock){//访问或修改由锁保护的共享状态}```

   2. 重入

      - 在java中当一个对象访问其他线程持有锁的请求时，就会出现等待，但是如果一个对象访问已经获取锁对象的请求时，那么这个请求就会访问成功，这说明java中锁操作的粒度是按照线程，而不是根据方法调用。
      - 在jvm中每个锁对象都关联一个计数器和一个所有者，当计数器等于0 时，说明该锁没有被任何线程锁持有，当线程持有该锁后对象的计数器变为1且记录下锁的持有线程，如果线程在此获取该锁那么计数器递增，如果线程释放那么计数器递减

4. 使用锁来保护状态

   在java中实现同步代码是为了在是共享的数据从并行访问转化成串行访问这样就可以在多线程中对状态进行独占访问从而保证状态已一致性

   当多个数据使用访问一个共享的状态的时候，不能只在当前操作中加锁，应该在其他任何操作也增加同步锁，否则可能会出现状态数据不一致的情况。对一个变量访问都需要同一个锁，那么这个状态是由这个锁保护的

   一种常用的加锁机制：在类内部所有有状态变更的操作都加锁，因此这个对象不会产生线程安全问题，但是如果对对象内部进行修改并且忘掉加锁会对这个对象产生破坏性

5. 活跃性与性能

   获取和释放锁都是有一定开销的因此不要把同步代码块拆分的太细，而且如果有同步代码块，就可以不使用线程安全的类，因为在同步代码块中使用线程安全的类不会带来性能和安全性的好处

   同步代码块的合理大小需要在性能、安全性和简单性之间做衡量，但是在简单性和性能之间会存在冲突。在代码中不能为了性能而盲目的牺牲掉简单性（有可能会破坏安全性）

   如果一个同步代执行需要大量的时间，那么就会使其他线程陷入等待从而影响线程的活跃性，如果一个执行时间较长或者会阻塞的代码时，尽量不要有锁例如io操作





































