# java并发编程实战

### 对象的共享

​	我们可以通过synchronize关键字来实现线程的原子操作，我们希望一个对象在更改一个状态的时候其他线程不能同时修改，也期望着一个线程更改状态以后其他的线程也能看到更改后的数据，因此就需要使用同步来保证对象被安全的发布

1. 可见性

   在单线的情况下我们对一个变量进行写的操作，那么我们在读的时候总能够读到相同的值，但是在多线程的情况下我们不能保证一个线程能够在适当的时间读取到另一个线程写的内容。因此必须使用同步来完成可见性。

   ``` java
   public class NoVisibility {
   
       private static boolean READ;
   
       private static int number;
   
       private static Object lock;
   
       public static void main(String[] args) {
   
           new Thread(() -> {
               synchronized (lock){
                   while (READ) {
                       //释放当前线程的锁，然后重新获取
                       //但是由于read不是线程内可见所以一直执行该方法
                       Thread.yield();
                   }
                   System.out.println(number);
               }
           }).start();
   
           number = 42;
           READ = true;
           System.out.println("main OK" );
   
       }
   }
   ```

   在NoVisibility中有一种结果可能会输出0，因为在没有同步的情况下，编译器、处理器以及运行时都可能对操作的执行顺序进行意想不到的调整，在缺乏足够同步的多线程环境中，想要对内存操作的执行顺序进行判断，几乎无法得到正确判断。这也就是重排序现象

   而为了避免这依情况的简单的方法就是只要有数据在多个线程之间共享，就使用正确的同步

   1. 失效数据

      在以上代码中还可能产生失效数据[^1]，也就是说当线程访问READ的时候有可能访问到的是一个失效的值，而一个线程中两个变量有可能其中一个是最新的值，另一个却是失效值，除非访问变量使用同步否则很有可能获取一个失效值

      失效数据可能会导致一些令人困惑的问题，例如意料之外的异常，不精准计算，无线循环，甚至会引发一些严重的安全性问题和活跃性问题

      ``` java
      public class MutableInteger {
      
          private int value;
      
          public int getValue() {
              return value;
          }
      
          public void setValue(int value) {
              this.value = value;
          }
      }
      ```

      ```MutableInteger``` 类不是现场安全的，因此在使用的时候就可能会引发数据失效，只有在get/set 方法上都增加synchronize关键字才会避免数据失效问题

   2. 非原子的64位操作

      最低安全性：就是在没有同步的情况下，很有可能读取到一个失效的值，但是这个失效的值是之前的某个线程设置的，而并非是一个随机数

      在某种情况下最低安全性是不成立的：也就是非volatile类型的double和long，在java内存模型中变量的读写操作都是原子操作，但是对于以上两种类型，jvm允许将64位的操作拆分成两个32位操作，因此在多线程中有可能读取高32位和第32位是两个值的。因此在多线程环境中使用long和double类型的变量是不安全的，除非使用volatile或者是同步机制

   3. 加锁和可见性

      内置锁可以用于在某个线程以可见性的凡是看到另一个线程的执行结果，也就是说在两个线程访问一个同步代码块是，第一个线程的修改的变量在第二个线程中可以全部查看。如果两个线程没有同步则无法看到，因此在一个共享且可变的变量的所有操作都添加统一个锁是为了在多个线程之间相互可见。否则有可能会读取到一个失效的数据。

      加锁的含义不仅局限于互斥行为，还包括内存可见性，为了保证所有的线程能看到共享变量的最新之，所有执行读写操作的线程都需要在一个锁上同步

   4. volatile 变量

      使用volatile关键字同步可以将变量的更新通知到其他线程，当声明为volatile类型后，编译器与运行是都会注意到这个变量是共享的因此不会进行重排序。volatile变量不会被缓存到寄存器或者其他处理器不可见的地方。因此volatile类型的变量时总会返回最新的值

      使用volatile关键字替换到get和set方法，数据失效问题就会解决，也不会试线程阻塞，因此volatile是一种更轻的加锁机制，在使用volatile提供的可见性使得锁的代码更加脆弱，也更难理解

      使用volatile关键字的正确方式

      - 确保自身状态的可见性，确保他们所引用的对象的状态的可见性
      - 标识一些重要的程序的生命周期时间的发生

      相比于volatile关键自来说，加锁机制既可以保证原子性又可以保证可见性，而volatile只能保证可见性

      使用volatile关键字需要满足一下条件

      - 对变量的写入操作不依赖变量的当前值，或者保证你确保只有单个线程更新值
      - 该变量不会与其他状态变量一起纳入不变形条件中
      - 在访问变量是不需要加锁

2. 发布于逸出

   发布一个对象就是指使对象能在当前作用域之外的代码中使用。将一个指向该对象的引用保存到其他可以访问的地方，或者在某个非私有方法中返回该引用，或者将引用传递到其他的类的方法中

   ``` java
   public static Set<Secret> knownSecret；
   public void initialize(){
   	knownSecret = new HashSet<Secret>();
   }
   ```

   当发布一个对象可以通过公共的方法调用其私有变量，那么该对象的私有变量也会被发布，当一个对象传递给某个外部方法是，就相当于发布了这个对象

   - 安全的对象构造过程

     在一个对象通过构造函数去发布一个函数的时候，不要在构造函数中创建新的线程，这样有可能这个对象的实例已经返回，但是这个对象还没有完全的发布成功

3. 线程的封闭

   由于共享可变数据需要同步才能保证线程安全，为了避免同步的操作可以使数据不共享，即在单个线程中访问。而这种技术就是线程封闭，当一个对象封闭在一个线程中，即使这个对象并非线程安全的类也能保证线程安全。

   相对于JDBC的Connection对象，每个Connection在返回连接池之前，只会被一个线程锁独享，因此就隐含的将Connection对象封闭在了单个的线程之中。

   线程封闭是在程序设计的时候进行考虑的，在程序的实现中java提供了一些机制来帮助完成线程的封闭，例如局部变量和TheadLocal。而我们在编程的时候需要考虑的是线程中的对象不会逸出当前线程

   1. Ad-hoc 线程封闭

      Ad-hoc线程封闭是指线程的封闭完全是由程序来实现的。但是这种线程封闭是非常脆弱。由于线程封闭没有任何语言特征。实际上对于封闭线程的引用通常保存在共有变量中,由于ad-hoc线程封闭相当的脆弱，因此推荐使用栈封闭或者是ThreadLocal来完成线程封闭

      在volatile变量上，如果能保证该变量的操作是在单个线程中执行，那么在这种情况下就相当于将volatile变量封闭在单个的线程中防止发生静态条件，但更新变量时，所有的线程都可见。

   2. 栈封闭

      每个线程都有自己对应的栈，在线程的内部使用局部变量[^2]的时候，其他的线程无法访问到局部变量的数据，所以比Ad-hoc更加容易也更健壮，正式如此栈封闭也被称为线程内部使用或线程局部使用

      ```java
      public int laodTheArk(Collection<Animal> datas){
          SortedSet<Animal> animals;
          int nums = 0;
          Animal ani = null;
          
          animals = new TreeSet<Animal>(new SpeciesGenderComparator());
          animals.add(datas);
          for(Animal an : animals){
              if(ani == null || !ani.isPotentialMate(a)){
                  ani = an
              } else {
                  ++nums;
                  ani = null;
              }
          }
          return nums;
      }
      ```

      在维持程序的栈封闭性的时候，需要多做一些事情确保引用的对象不会被逸出。如上代码animals是一个TreeSet的对象，并且封闭到线程的局部变量中

      3. ThreadLocal类

      



















[^1]: 过期数据就类似于数据库的读写级别一样，类似于脏读，牺牲了准确性来提升性能
[^2]: 局部变量的固有属性就是封闭在执行的过程中

